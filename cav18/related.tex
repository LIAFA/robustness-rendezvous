%!TEX root = main.tex
\section{Related Work}\label{sec:related}

Automatic verification of asynchronous message passing systems is undecidable in general~\cite{DBLP:journals/jacm/BrandZ83}. 
%This follows from the results of~\cite{DBLP:journals/jacm/BrandZ83}, where the authors prove that checking reachability and deciding boundedness of the queues in message passing systems is undecidable. 
A number of decidable subclasses has been proposed. 
The class of systems, called \emph{synchronizable} as well, in~\cite{DBLP:journals/tcs/BasuB16}, requires that a system generates the same sequence of send actions when executed under the asynchronous semantics as when executed under a synchronous semantics based on rendezvous communication. These systems are all $1$-synchronizable, but the inclusion is strict (the $1$-synchronous semantics allows unmatched sends). The techniques proposed in~\cite{DBLP:journals/tcs/BasuB16} to check that a system is synchronizable according to their definition cannot be extended to $k$-synchronizable systems.
Other classes of systems that are $1$-synchronizable have been proposed in the context of session types, e.g.,~\cite{DBLP:conf/esop/DenielouY12,DBLP:journals/jacm/HondaYC16,DBLP:conf/esop/HondaVK98,DBLP:conf/popl/LangeTY15}. A sound but incomplete proof method for distributed algorithms that is based on a similar idea of avoiding reasoning about all program computations is introduced in~\cite{DBLP:journals/pacmpl/BakstGKJ17}.
Our class of synchronizable systems differs also from classes of communicating systems that restrict the type of communication, e.g., lossy-communication~\cite{DBLP:journals/iandc/AbdullaJ96}, half-duplex communication~\cite{DBLP:journals/iandc/CeceF05}, or the topology of the interaction, e.g., tree-based communication in concurrent pushdowns~\cite{DBLP:conf/tacas/TorreMP08,DBLP:journals/corr/abs-1209-0359}.

The question of deciding if all computations of a communicating system are equivalent (in the language theoretic sense) to computations with bounded buffers has been studied in, e.g., \cite{DBLP:journals/fuin/GenestKM07}, where this problem is proved to be undecidable. The link between that problem and our synchronizability problem is not (yet) clear, mainly because non synchronizable computations may use bounded buffers.

Our work proposes a solution to the question of defining adequate (in terms of coverage and complexity) parametrized bounded analyses for message passing programs, providing the analogous of concepts such as context-bounding or delay-bounding defined for shared-memory concurrent programs. Bounded analyses for concurrent systems
% in general (communicating through a shared memory or message passing) 
was initiated by the work on bounded-context switch analysis~\cite{DBLP:conf/pldi/QadeerW04,DBLP:conf/tacas/QadeerR05,DBLP:conf/cav/LalR08}. For shared-memory programs, this work has been extended to unbounded threads or larger classes of behaviors, e.g.,~\cite{DBLP:conf/sas/BouajjaniEP11,DBLP:conf/popl/EmmiQR11,DBLP:conf/spin/KiddJV10,DBLP:conf/cav/TorreMP10}. Few bounded analyses incomparable to ours have been proposed for message passing systems, e.g.,~\cite{DBLP:conf/tacas/TorreMP08,DBLP:conf/tacas/BouajjaniE12}. Contrary to our work, these works on bounded analyses in general do not propose decision procedures for checking if the analysis is complete (covers all reachable states). The only exception is~\cite{DBLP:conf/cav/TorreMP10}, which concerns shared-memory.  

Partial-order reduction techniques, e.g.,~\cite{DBLP:conf/popl/AbdullaAJS14,DBLP:conf/popl/FlanaganG05}, allow to define equivalence classes on behaviors, based on notions of action independence and explore (ideally) only one representative of each class. This has lead to efficient algorithmic techniques for enhanced model-checking of concurrent shared-memory programs that consider only a subset of relevant action interleavings. In the worst case, these techniques will still need to explore all of the interleavings. Moreover, these techniques are not guaranteed to terminate when the buffers are unbounded.

The work in~\cite{DBLP:conf/oopsla/Desai0M14} defines a particular class of schedulers, that roughly, prioritize receive actions over send actions, which is complete in the sense that it allows to construct the whole set of reachable states. Defining an analysis based on this class of schedulers has the same drawback as partial-order reductions, in the worst case, it needs to explore all interleavings, and termination is not guaranteed. 

%The notion of conflict-graph is similar to the one used for defining conflict serializability~\cite{journals/jacm/Papadimitriou79b}. However, our algorithms and proof techniques are very different from those used in this context, e.g.,~\cite{DBLP:journals/iandc/AlurMP00,DBLP:conf/esop/BouajjaniEEH13,DBLP:conf/cav/FarzanM08}. Our approach considers several classes of cycles in these graphs and focuses on showing that these cycles can be detected without exploring all the behaviors of a system.

The approach in this work is related to robustness checking \cite{DBLP:conf/se/BouajjaniDM14,DBLP:conf/esop/BouajjaniEEOT17}. The general paradigm is to decide that a program has the same behaviors under two semantics, one being weaker than the other, by showing a polynomial reduction to a state reachability problem under the stronger semantics.
%, i.e., by avoiding the consideration of the weak semantics that is in general far more complex to deal with than the strong one. 
For instance, in our case, the class of message passing programs with unbounded FIFO channels is Turing powerful, but still, surprisingly, $k$-synchronizability of these programs is decidable and PSPACE-complete. % (i.e., as hard as state reachability in programs with bounded channels). 
The results in \cite{DBLP:conf/se/BouajjaniDM14,DBLP:conf/esop/BouajjaniEEOT17} cannot be applied in our context:
%in each of \cite{DBLP:conf/se/BouajjaniDM14}, \cite{DBLP:conf/esop/BouajjaniEEOT17}, and our work, 
the class of programs and their semantics are different, and the corresponding robustness checking algorithms are based on distinct concepts and techniques.
% (shared-memory concurrent programs running over a relaxed memory model in \cite{DBLP:conf/se/BouajjaniDM14}, and shared-memory concurrent programs with dynamic asynchronous process creation in \cite{DBLP:conf/esop/BouajjaniEEOT17}), and the corresponding robustness checking algorithms are based on distinct concepts and techniques. 
%While in \cite{esop13} the question of checking that shared-memory concurrent programs running over the relaxed memory model TSO are sequentially consistent, in \cite{esop17} we consider asynchronous programs with dynamic task creation communicating through a shared memory, whereas here, we consider concurrent systems communicating through FIFO channels, without shared memory.

