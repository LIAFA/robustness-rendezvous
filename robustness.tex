%!TEX root = main.tex
\section{Synchronizability}

We define a notion of robustness, called \emph{synchronizability}, which ensures that even if the system uses buffers to store messages it provides the illusion that messages are received instantaneously, as in a synchronous (rendez-vous) semantics. This is analogous to the atomicity criterion for concurrent shared-memory systems, where even though transactions can interleave, every execution is “equivalent” to an execution where transactions happen atomically without interference.

%\subsection{Defining Robustness}

We define a conflict relation $\prec$ on actions in $S_{id}\cup R_{id}$ that relates every two actions of the same process and every send with the corresponding receive. Formally,
\begin{align*}
a \prec a'\mbox{ iff } \<proc>(a) = \<proc>(a')\mbox{ or } a\match a'
\end{align*}

A permutation $t'$ of a trace $t$ is \emph{conflict-preserving} when every pair $a$ and $a'$ of actions of $t$ appear in the same order in $t'$ whenever $a \prec a'$. 
From now on, whenever we use the term permutation we mean conflict-preserving permutation.
Intuitively, a message passing system can not distinguish between two traces, one being a conflict-preserving permutation of the other.

\begin{example}\label{ex:perm}
The following traces 
\begin{align*}
\send{1}{p_1,q,\_}\ 
\send{2}{p_2,q,\_}\ 
\rec{1}{q,\_}\ 
\rec{2}{q,\_} \\
\send{1}{p_1,q_1,\_}\ 
\send{2}{p_2,q_2,\_}\ 
\rec{2}{q_2,\_}\ 
\rec{1}{q_1,\_} 
\end{align*}
have the following conflict-preserving permutations, respectively:
\begin{align*}
\send{1}{p_1,q_1,\_}\ 
\rec{1}{q,\_}\ 
\send{2}{p_2,q,\_}\ 
\rec{2}{q,\_} \\
\send{1}{p_1,q_1,\_}\ 
\rec{1}{q_1,\_}\ 
\send{2}{p_2,q_2,\_}\ 
\rec{2}{q_2,\_}\ 
\end{align*}
\end{example}

\begin{lemma}
For a given trace $t$, $\asynchTr{A}$ contains every conflict-preserving permutation $t'$ of $t$ when $t\in \asynchTr{A}$.
\end{lemma}

A trace $t$ is called \emph{synchronous} when every send $s\in S_{id}$ is immediately followed by the matching receive. Formally, for every $0\leq k< |t| -1$, if $t_k\in S_{id}$ then $t_{k+1}\in R_{id}$ and $t_{k}\match t_{k+1}$.

Informally, a trace  $t$ is called \emph{synchronizable} when there exists a synchronous conflict-preserving permutation of $t$. 
However, the presence of send actions without a matching receive introduces a subtlety: a trace is considered synchronizable by supposing that every message is eventually received.
To account for this, we define a \emph{completion} of a trace $t$ to be any sequence $t\cdot t'$ where $t'$ contains only receive actions that match one of the unmatched send actions in $t$.

\begin{definition}
A trace $t$ is called \emph{synchronizable} when there exists a synchronous conflict-preserving permutation of a completion of $t$. 
\end{definition}

\begin{example}
The traces in Example~\ref{ex:perm} are synchronizable while the following are not:
\begin{align*}
\send{1}{p,q,\_}\ 
\send{2}{p,q,\_}\ 
\rec{2}{q,\_}\ 
\rec{1}{q,\_} \\
\send{1}{p,q,\_}\ 
\send{2}{q,p,\_}\ 
\rec{2}{p,\_}\ 
\rec{1}{q,\_} 
\end{align*}
\end{example}

A message passing system $A$ is synchronizable when every trace $t\in \asynchTr{A}$ is  synchronizable.

\begin{figure} [t]
\footnotesize{
  \centering
  \begin{mathpar}
    \inferrule[send]{
      l\in \delta(\vec{l}_p,\senda{p,q,v}) \neq \emptyset \\
      \mathrm{empty}(\vec{b}_j) \mbox{ for all $j$} 
    }{
      \vec{l},\vec{b}
      \xRightarrow{\senda{p,q,v}}
      \vec{l}[\vec{l}_p\gets l],\vec{b}[\vec{b}_q.\ \mathrm{add}(v)]
    }%\hspace{5mm}

%    \inferrule[orphan send]{
%      m= \tup{i,j,p} \\
%      \delta(\vec{l}_i,\send{i}{m})\neq \emptyset
%    }{
%      \vec{l},\vec{b}
%      \xRightarrow{\send{i}{m}}
%      \vec{l}[\vec{l_i}\gets \delta(\vec{l}_i,\send{i}{m})],\vec{b}
%    }%\hspace{5mm}
    
        \inferrule[local]{ 
      l \in \delta(\vec{l}_p,\epsilon) \neq \emptyset
    }{
      \vec{l},\vec{b}
      \xrightarrow{\epsilon}
      \vec{l}[\vec{l}_p\gets l],\vec{b}
    }%\hspace{5mm}
    
    \inferrule[receive]{
      v = \vec{b}_q.\ \mathrm{rem}() \\
      l\in \delta(\vec{l}_q,\reca{q,v}) \neq \emptyset \\
      \mathrm{empty}(\vec{b}_j) \mbox{ for all $j\neq q$} 
    }{
      \vec{l},\vec{b}
      \xRightarrow{\reca{q,v}}
      \vec{l}[\vec{l}_q\gets l],\vec{b}[\vec{b}_q.\ \mathrm{rem}()]
    }%\hspace{5mm}
  \end{mathpar}
  }
% \vspace{-5mm}
  \caption{The synchronous semantics of a message passing system $A$. The predicate $\mathrm{empty}(\vec{b}_j)$ denotes the fact that the buffer $\vec{b}_j$ is empty, i.e, $\vec{b}_j.\ \mathrm{rem}()$ is not enabled.}
  \label{fig:synch-sem}
%\vspace{-6mm}
\end{figure}

The transition relation $\Rightarrow$ in Figure~\ref{fig:asynch-sem} defines a new semantics for  a message passing system $A$
where a receive for process $q$ is enabled only if the buffers of all the other processes are empty. Executions and reachable local
state vectors under the new semantics, denoted by $\synch{States}(A)$, are defined as in Section~\ref{sec:prelims}.
The set of traces of $A$ under the new semantics is denoted by $\synch{Tr}(A)$.

TODO DESCRIBE TRANSITIONS 

\begin{lemma}\label{lem:sync_traces}
The synchronous semantics of a message passing system admits every synchronous trace.
\end{lemma}

TODO DEFINE THE CONDITION XXX THAT EVERY MESSAGE IS RECEIVED

\begin{lemma}
For a given synchronizable XXX message passing system $A$, $\asynch{States}(A)=\synch{States}(A)$.
\end{lemma}
\begin{proof}
TODO 
\end{proof}

Checking that a given trace is synchronizable can be done by tracking a ``conflict-graph'' like in serializability 
where transactions are pairs of sends and matching receives. 
A trace is synchronizable if{f} the conflict-graph is acyclic. Formally,

\begin{definition}[Action-Graph]\label{def:pr_graphs}
    The \emph{action-graph} of a trace $t$ is the directed graph 
    $G_t = \tup{V,E}$ where there is a node in $V$ for each action in $t$, and $E$ 
    contains an edge from $u$ to $v$ iff $\mathrm{act}(u) \prec \mathrm{act}(v)$ and $\mathrm{act}(u)$ occurs before $\mathrm{act}(v)$ in $t$ (where $\mathrm{act}(v)$ is the action of trace $t$ corresponding to the graph node $v$).
\end{definition}
Intuitively, one can think of the action-graph of a trace $t$ as a structure that represents the order between all conflicting actions in $t$.
%AND THE WEAKEST CONSTRAINTS THAT CAN BE ADDED BY A COMPLETION.
For two actions $a$ and $a'$ in a trace $t$, $a\leadsto a'$ denotes the fact that $G_t$ contains a path from the node representing $a$ to that representing $a'$.

\begin{lemma}\label{lem:acyclic_ag}
	The \emph{action-graph} of a trace is acyclic. Moreover, $\rec{1}{q_1,\_}\leadsto \send{2}{p_2,q_2,\_}$ and $\rec{2}{q_2,\_}\leadsto \send{1}{p_1,q_1,\_}$ is impossible for any possible instantiation of $p_1$, $q_1$, $p_2$, and $q_2$.
\end{lemma}

TODO BELOW WE ADD EDGES FROM A SEND/RECEIVE PAIR TO EVERY UNMATCHED SEND THAT HAS THE SAME DESTINATION

\begin{definition}[Conflict-Graph]\label{def:conf_graph}
    The \emph{conflict-graph} of a trace $t$ is the directed graph $CG_t=\tup{V',E'}$ where $V'$ includes one node for each pair of matching send and receive actions, and each unmatched send action, in $t$, and we have $(v,v') \in E'$ iff one of the following holds
\begin{itemize}
    	\item there exist actions $a \in \mathrm{act}(v)$ and $a' \in \mathrm{act}(v')$ such that $(a,a') \in E$ where $G_t = (V,E)$ is the action-graph of $t$ (and $\mathrm{act}(v)$ is the set of actions of trace $t$ corresponding to the graph node $v$), or
	\item $\mathrm{act}(v)$ consists of a pair of matching send and receive actions, and $\mathrm{act}(v')$ consists of only a send action.
\end{itemize}
\end{definition}



\begin{theorem}\label{thm:cg} 
A trace $t$ is synchronizable if{f} $CG_t$ is acyclic.
\end{theorem}
\begin{proof}
Let $t$ be a synchronizable trace. Then, there exists a completion $t'$ of $t$ and a permutation $t''$ of $t'$ which is synchronous. The definition of the conflict-graph implies that $CG_{t''}$ is acyclic which implies that $CG_{t'}$ is also acyclic (conflict-preserving permutations have the same conflict-graph as the original trace). Then, $t$ is obtained from $t'$ by removing receive actions and thus, $CG_{t}$ is a sub-graph of $CG_{t'}$ which implies that $CG_{t}$ is also acyclic.

For the reverse, let $t$ be a trace with an acyclic conflict graph. Let $t'=t\cdot t_c$ be a completion of $t$ where the receive actions in $t_c$ occur in the same order as the matching sends in $t$. Thus, for every two send actions $s_1=\send{i}{p_1,q_1,v_1}$ and $s_2=\send{j}{p_2,q_2,v_2}$ unmatched in $t$, $t_c$ contains $\rec{i}{q_1,v_1}$ followed by $\rec{j}{q_2,v_2}$. We show that $CG_{t'}$ is isomorphic to $CG_{t}$. By definition, the two conflict graphs have the same number of nodes. It remains to prove that they have exactly the same set of edges. Thus, let $v$ and $v'$ be two nodes of $CG_{t}$. Assume that $v$ represents an unmatched send action $s_1=\send{i}{p_1,q_1,v_1}$ (the case where $v$ and $v'$ represent pairs of matching send and receive actions is trivial).
There are two cases to consider:
\begin{itemize}
	\item if $v'$ represents a pair of matching send and receive actions, then $CG_{t}$ contains an edge $(v',v)$ (but no $(v,v')$ since $CG_{t}$ is acyclic). And this edge is contained also in $CG_{t'}$.
	\item otherwise, assume that $v'$ represents an unmatched send action $s_2=\send{j}{p_2,q_2,v_2}$ which follows $s_1$ in $t$. 
	\begin{itemize}
		\item if $(v,v')$ is an edge of $CG_{t}$ (by definition, $(v',v)$ can not be an edge of $CG_{t}$) then $p_1=p_2$. Then, $(v,v')$ is also an edge of $CG_{t'}$.
		\item if $(v,v')$ is an edge of $CG_{t'}$, then there are two cases. Either $p_1=p_2$ which is similar to the previous case, or $q_1=q_2$.
		Since $\rec{i}{q_1,v_1}$ occurs before $\rec{j}{q_2,v_2}$ in $t'$, $(v,v')$
	\end{itemize}
\end{itemize}


We define a completion of $t$ for which there exists a synchronous permutation. 


Thus, let $s_1=\send{i}{p_1,q_1,v_1}$ and $s_2=\send{j}{p_2,q_2,v_2}$ be two unmatched send actions occurring in this order in $t$. If $s_1\leadsto s_2$, then we choose a completion where $\rec{i}{q_1,v_1}$ occurs before $\rec{j}{q_2,v_2}$.
\end{proof}



