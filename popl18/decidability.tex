%!TEX root = main.tex
\section{Decidability results}

We investigate several decidability and asymptotic complexity questions concerning the synchronous semantics and synchronizability. In this context, we consider finite-state message passing systems, where each process has a bounded number of local states.  We show that the reachability problem under the synchronous semantics, and checking $k$-synchronizability, are both decidable and PSPACE-complete. Therefore, even though these problems deal with asynchronous communicating systems, they have the same complexity as the reachability problem in a system using rendez-vous communication. Then, we give a class of systems for which the problem of checking whether there exists some $k$ such that they are  $k$-synchronizable is decidable.

Given a system $\mathcal{S}$, an integer $k$, and a local state $l$, \emph{the reachability problem under the $k$-synchronous semantics} asks whether $\synchSt{\mathcal{S}}{k}$ contains a configuration $(\vec{l},B)$ with $l=\vec{l}_p$ for some $p\in\<Pids>$.

\begin{theorem}\label{th:dec1}
The reachability problem under the $k$-synchronous semantics is decidable and PSPACE-complete.
\end{theorem}
\begin{proof}
A consequence of the fact that the product emptiness problem (checking if the product of a set of finite state automata has an empty language) is PSPACE-complete~\cite{DBLP:conf/focs/Kozen77}. The evolution of the $B$ component of a synchronous configuration and the set of messages sent during a $k$-exchange transition can be modeled using a labeled transition system that is composed with the processes in the system. 
\end{proof}

\begin{theorem}
The problem of checking $k$-synchronizability of a finite-state system $\mathcal{S}$ is decidable and PSPACE-complete.
\end{theorem}
\begin{proof}
Theorem~\ref{th:main-verif} and Theorem~\ref{th:dec1} imply that the problem is in PSPACE. Moreover, PSPACE-hardness follows from the fact that the product emptiness problem can be reduced to checking $1$-synchronizability. Given a set of finite state automata $A_1$, $\ldots$, $A_n$, we define a message passing system $\mathcal{S}$ containing one process $p_i$ for each automaton $A_i$, which ``simulates'' the product. Essentially, $p_1$ is obtained from $A_1$ by rewriting every transition label $a$ to $\senda{p_1,p_2,a_1}\cdot \reca{p_1,a_n}$, $p_i$ with $1<i<n$ is obtained from $A_i$ by rewriting every transition label $a$ to $\reca{p_i,a_{i-1}}\cdot \senda{p_i,p_{i+1},a_i}$, and $p_n$ is obtained from $A_n$ by rewriting every transition label $a$ to $\reca{p_n,a_{n-1}}\cdot \senda{p_n,p_1,a_n}$. This rewriting ensures that every transition of the product of $A_1\times\ldots\times A_n$ is simulated precisely by a sequence of sends/receives:
\begin{align*}
\senda{p_1,p_2,a_1}\cdot \reca{p_2,a_1}\cdot \senda{p_2,p_3,a_2}\cdot\ldots \cdot \reca{p_n,a_{n-1}} \senda{p_n,p_1,a_n}\cdot \reca{p_1,a_n}
\end{align*}
Note that every execution admitted by this system is $1$-synchronous. Augmenting this system with new states and transitions to ensure that it produces a violation of $1$-synchronizability exactly when each process $p_i$ is in a final state of $A_i$, leads to a system which is \emph{not} $1$-synchronizable iff the product $A_1\times\ldots\times A_n$ has a non-empty language. Therefore, the product emptiness problem is polynomial-time reducible to checking $1$-synchronizability.
\end{proof}

\begin{figure}
\includegraphics[width=7cm]{Ex-Decidability.pdf}
\caption{An example of a system which is not $k$-synchronizable, for every $k$.}
\label{fig:decid_ex}
\end{figure}

We now give a syntactical criterion that imposes an upper bound on the number $k$ for which a system could be $k$-synchronizable.
In general, there are two reasons for which a system is not $k$-synchronizable, for every $k$. It either admits an execution with a bad conflict-graph cycle (e.g., the execution in Figure~\ref{fig:ex-rs-cycle}), or it admits executions with infinitely increasing conflict-graph cycles. If a system admits a bad conflict-graph cycle, then there exists a $k$ for which it can be shown to be non $k$-synchronizable (a coarse upper bound for $k$ is the length of the execution containing this cycle). The second case is more problematic and it is exemplified by the system in Figure~\ref{fig:decid_ex}. 
The two loops in each process allow to create executions with unboundedly many send actions before any receive is enabled. However, this example is artificial, and the systems we have encountered in practice do not contain such scenarios. 

In fact, the large majority of the processes composing practical systems, e.g., systems developed in the P language~\footnote{Available at \url{https://github.com/p-org}.}, perform a bounded number of consecutive sends or receives. If all processes in the system would satisfy this constraint, then there exists a bound $k_s$ on the number of sends that are enabled before a receive, which would imply that the system is $k$-synchronizable for some $k$ iff it is $k$-synchronizable for some $k\leq k_s$. However, there exist processes which don't satisfy this constraint, e.g., the process ${\tt User}$ in Figure~\ref{fig:elevator}, which performs an unbounded number of consecutive send actions. Typically, these processes model the environment, in this case the set of users of the elevator. Note however that a more precise representation of the environment would have to include receive actions for every request of the user, which will make the system perform a bounded sequence of sends before a receive.

Let $\mathcal{S}=((\<Lsts>_p,\delta_p,l_p^0)\mid p\in\<Pids>)$ be a message passing system. A process $p$ is called $k$-bounded when intuitively, it can perform at most $k$ consecutive sends or receives. Formally, for every sequence $w\in (S_{id}\cup R_{id})^*$ accepted by the labeled transition system $(\<Lsts>_p,\delta_p,l_p^0)$, there exists no decomposition $w=w_1\cdot w_2\cdot w_3$ where $w_2\in S_{id}^*\cup R_{id}^*$ and the length of $w_2$ is strictly bigger than $k$. For instance, all the processes in the distributed commit protocol in Figure~\ref{fig:commit} are $2$-bounded (more precisely, the manager is $2$-bounded and the rest of the processes are $1$-bounded). On the other hand, the processes in Figure~\ref{fig:elevator} are not $k$-bounded, for every $k$.

\begin{theorem}
Given a system $\mathcal{S}$ which is ???, the problem of checking if there exists some $k$ such that $\mathcal{S}$ is $k$-synchronizable, is decidable.
\end{theorem}
\begin{proof}
\end{proof}