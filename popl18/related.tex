%!TEX root = main.tex
\section{Related Work}

Automatic verification of asynchronous message passing systems is undecidable in general. This follows from the results of~\cite{DBLP:journals/jacm/BrandZ83}, where the authors prove that checking reachability and deciding boundedness of the queues in message passing systems is undecidable. 
Therefore, a number of decidable subclasses has been proposed. 
The class of systems, called \emph{synchronizable} as well, proposed in~\cite{DBLP:journals/tcs/BasuB16}, requires that a system generates the same sequence of send actions when executed under the asynchronous semantics as when executed under a synchronous semantics based on rendez-vous communication. This class of systems is included in the class of $1$-synchronizable systems, and the inclusion is strict (this is because the $1$-synchronous semantics allows unmatched sends which cannot be produced by rendezvous communication). However, the techniques proposed in~\cite{DBLP:journals/tcs/BasuB16} to check that a system is synchronizable according to their definition cannot be extended to $k$-synchronizable systems.
Other classes of systems that are $1$-synchronizable according to our definition have been proposed in the context of session types, e.g.,~\cite{DBLP:conf/esop/DenielouY12,DBLP:journals/jacm/HondaYC16,DBLP:conf/esop/HondaVK98,DBLP:conf/popl/LangeTY15}. 
Our class of synchronizable systems differs also from other classes of communicating systems that restrict the type of communication, e.g., lossy-communication~\cite{DBLP:journals/iandc/AbdullaJ96}, half-duplex communication~\cite{DBLP:journals/iandc/CeceF05}, or the topology of the interaction, e.g., tree-based communication in particular classes of push-down systems~\cite{DBLP:conf/tacas/TorreMP08,DBLP:journals/corr/abs-1209-0359}.

Bounded analyses for concurrent systems in general (communicating through a shared memory or message passing) was initiated by the work on bounded-context switch analysis for multi-threaded programs~\cite{DBLP:conf/pldi/QadeerW04,DBLP:conf/tacas/QadeerR05,DBLP:conf/cav/LalR08}. In the context of shared-memory programs, this work has been extended to cover an unbounded number of threads or a larger class of behaviors, e.g.,~\cite{DBLP:conf/sas/BouajjaniEP11,DBLP:conf/popl/EmmiQR11,DBLP:conf/spin/KiddJV10,DBLP:conf/cav/TorreMP10}. Several bounded analyses incomparable to ours have been proposed for message passing systems, e.g.,~\cite{DBLP:conf/tacas/TorreMP08, DBLP:conf/tacas/BouajjaniE12}. In general, these works don't propose decision procedures for checking if a bounded analysis is complete, in the sense that it covers the whole set of reachable states. The only exception that we are aware of is~\cite{DBLP:conf/cav/TorreMP10}, which however is very different from our work since it concerns shared-memory programs.

Partial-order reduction techniques, e.g.,~\cite{DBLP:conf/popl/AbdullaAJS14,DBLP:conf/popl/FlanaganG05}, allow to define equivalence classes on behaviors, based on notions of action independence and explore (ideally) only one representative of each class. This has lead to efficient algorithmic techniques for enhanced model-checking of concurrent shared-memory programs that consider only a subset of relevant action inter-leavings. Still in the worst case, these techniques will need to explore all (or a large number) of the interleavings. 

The work in~\cite{DBLP:conf/oopsla/Desai0M14} defines a particular class of schedulers, that roughly, prioritize receive actions over send actions, which is complete in the sense, that it allows to construct the whole set of reachable states. Defining an analysis based on this class of schedulers has the same drawback as partial-order reduction, i.e., in the worst case, it needs to explore all the interleavings.
