%!TEX root = main.tex
\section{Related Work}\label{sec:related}

Automatic verification of asynchronous message passing systems is undecidable in general. This follows from the results of~\cite{DBLP:journals/jacm/BrandZ83}, where the authors prove that checking reachability and deciding boundedness of the queues in message passing systems is undecidable. Therefore, a number of decidable subclasses has been proposed. 
The class of systems, called \emph{synchronizable} as well, proposed in~\cite{DBLP:journals/tcs/BasuB16}, requires that a system generates the same sequence of send actions when executed under the asynchronous semantics as when executed under a synchronous semantics based on rendezvous communication. This class of systems is included in the class of $1$-synchronizable systems, and the inclusion is strict (this is because the $1$-synchronous semantics allows unmatched sends which cannot be produced by rendezvous communication). However, the techniques proposed in~\cite{DBLP:journals/tcs/BasuB16} to check that a system is synchronizable according to their definition cannot be extended to $k$-synchronizable systems.
Other classes of systems that are $1$-synchronizable according to our definition have been proposed in the context of session types, e.g.,~\cite{DBLP:conf/esop/DenielouY12,DBLP:journals/jacm/HondaYC16,DBLP:conf/esop/HondaVK98,DBLP:conf/popl/LangeTY15}. 
Our class of synchronizable systems differs also from other classes of communicating systems that restrict the type of communication, e.g., lossy-communication~\cite{DBLP:journals/iandc/AbdullaJ96}, half-duplex communication~\cite{DBLP:journals/iandc/CeceF05}, or the topology of the interaction, e.g., tree-based communication in particular classes of push-down systems~\cite{DBLP:conf/tacas/TorreMP08,DBLP:journals/corr/abs-1209-0359}.

The question of deciding if all computations of a communicating system are equivalent (in the language theoretic sense) to computations with bounded buffers has been studied in, e.g., \cite{DBLP:journals/fuin/GenestKM07}, where this problem is proved to be undecidable. However, the link between that problem and our synchronizability problem is not (yet) clear, mainly because non synchronizable computations do not need to use unbounded buffers.

Bounded analyses for concurrent systems in general (communicating through a shared memory or message passing) was initiated by the work on bounded-context switch analysis for multi-threaded programs~\cite{DBLP:conf/pldi/QadeerW04,DBLP:conf/tacas/QadeerR05,DBLP:conf/cav/LalR08}. In the context of shared-memory programs, this work has been extended to cover an unbounded number of threads or a larger class of behaviors, e.g.,~\cite{DBLP:conf/sas/BouajjaniEP11,DBLP:conf/popl/EmmiQR11,DBLP:conf/spin/KiddJV10,DBLP:conf/cav/TorreMP10}. Several bounded analyses incomparable to ours have been proposed for message passing systems, e.g.,~\cite{DBLP:conf/tacas/TorreMP08,DBLP:conf/tacas/BouajjaniE12}. In general, these works do not propose decision procedures for checking if a bounded analysis is complete, in the sense that it covers the whole set of reachable states. The only exception that we are aware of is~\cite{DBLP:conf/cav/TorreMP10}, which however is very different from our work since it concerns shared-memory programs.

Partial-order reduction techniques, e.g.,~\cite{DBLP:conf/popl/AbdullaAJS14,DBLP:conf/popl/FlanaganG05}, allow to define equivalence classes on behaviors, based on notions of action independence and explore (ideally) only one representative of each class. This has lead to efficient algorithmic techniques for enhanced model-checking of concurrent shared-memory programs that consider only a subset of relevant action interleavings. Still in the worst case, these techniques will need to explore all (or a large number) of the interleavings. Moreover, these techniques are not guaranteed to terminate when the buffers can grow unboundedly.

The work in~\cite{DBLP:conf/oopsla/Desai0M14} defines a particular class of schedulers, that roughly, prioritize receive actions over send actions, which is complete in the sense, that it allows to construct the whole set of reachable states. Defining an analysis based on this class of schedulers has the same drawback as partial-order reductions, i.e., in the worst case, it needs to explore all the interleavings, and it is not guaranteed to terminate. 

The notion of conflict-graph is similar to the one used for defining conflict serializability in the context of shared-memory concurrency~\cite{journals/jacm/Papadimitriou79b}. However, our algorithms and proof techniques are very different from those used in this context, e.g.,~\cite{DBLP:journals/iandc/AlurMP00,DBLP:conf/esop/BouajjaniEEH13,DBLP:conf/cav/FarzanM08}. Our approach considers several classes of cycles in these graphs and focuses on showing that these cycles can be detected without exploring all the behaviors of a system.